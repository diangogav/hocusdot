# Set up the prompt

autoload -Uz promptinit
promptinit
# prompt adam1

# Use emacs keybindings even if our EDITOR is set to vi
bindkey -e

# ============================================================================
# History Configuration
# ============================================================================
HISTSIZE=50000                    # Lines of history in memory
SAVEHIST=50000                    # Lines of history to save to file
HISTFILE=~/.zsh_history           # History file location

# History options
setopt EXTENDED_HISTORY           # Record timestamp of command in HISTFILE
setopt HIST_EXPIRE_DUPS_FIRST     # Delete duplicates first when HISTFILE size exceeds HISTSIZE
setopt HIST_IGNORE_DUPS           # Ignore duplicated commands history list
setopt HIST_IGNORE_SPACE          # Ignore commands that start with space
setopt HIST_VERIFY                # Show command with history expansion before running it
setopt INC_APPEND_HISTORY         # Add commands to HISTFILE immediately, not on shell exit
setopt SHARE_HISTORY              # Share command history data between sessions

# Dotfiles directory
export DOTFILES_PATH="$HOME/.dotfiles"

# Add scripts folder
# export PATH="$PATH:$DOTFILES_PATH/scripts/:"
export PATH=~/.dotfiles/scripts:${PATH}
export PATH="$PATH:$HOME/.local/bin"
export PATH="$PATH:$HOME/.local/share/fnm"

# Environment Variables
# source $DOTFILES_PATH/terminal/private-exports.sh

# Load aliases file
source $DOTFILES_PATH/terminal/aliases

# Load Starship
eval "$(starship init zsh)"

# load ZSH completions
source $DOTFILES_PATH/terminal/zsh/completion.zsh

# ============================================================================
# Zinit Plugin Manager
# ============================================================================
ZINIT_HOME="${XDG_DATA_HOME:-${HOME}/.local/share}/zinit/zinit.git"

# Install zinit if not present
if [[ ! -d "$ZINIT_HOME" ]]; then
   mkdir -p "$(dirname $ZINIT_HOME)"
   git clone https://github.com/zdharma-continuum/zinit.git "$ZINIT_HOME"
fi

# Load zinit
source "${ZINIT_HOME}/zinit.zsh"

# ============================================================================
# Plugins
# ============================================================================

# Load plugins with turbo mode (lazy loading)
zinit wait lucid for \
  atinit"zicompinit; zicdreplay" \
    zdharma-continuum/fast-syntax-highlighting \
  atload"_zsh_autosuggest_start" \
    zsh-users/zsh-autosuggestions \
  blockf atpull'zinit creinstall -q .' \
    zsh-users/zsh-completions

# History substring search (bind after loading)
zinit ice wait lucid atload'bindkey "^[[A" history-substring-search-up; bindkey "^[[B" history-substring-search-down'
zinit light zsh-users/zsh-history-substring-search

# You-should-use (reminds you of aliases)
zinit ice wait lucid
zinit light MichaelAquilina/zsh-you-should-use

# ============================================================================
# Modern Tools Integration
# ============================================================================

# FNM (Fast Node Manager) - Lazy loaded
[ -f $DOTFILES_PATH/terminal/nodejs/fnm.zsh ] && source $DOTFILES_PATH/terminal/nodejs/fnm.zsh

# Zoxide (smart cd replacement)
if command -v zoxide &> /dev/null; then
  eval "$(zoxide init zsh)"
fi

# ZSH Configurations
set -o noclobber #ensure that shell redirection will not overwrite existing files

[ -f ~/.fzf.zsh ] && source ~/.fzf.zsh


_reverse_search() {
  local selected_command=$(fc -rl 1 | awk '{$1="";print substr($0,2)}' | fzf)
  LBUFFER=$selected_command
}

zle -N _reverse_search
bindkey '^r' _reverse_search

###-begin-npm-completion-###
#
# npm command completion script
#
# Installation: npm completion >> ~/.bashrc  (or ~/.zshrc)
# Or, maybe: npm completion > /usr/local/etc/bash_completion.d/npm
#

if type complete &>/dev/null; then
  _npm_completion () {
    local words cword
    
    if type _get_comp_words_by_ref &>/dev/null; then
      _get_comp_words_by_ref -n = -n @ -n : -w words -i cword
    else
      cword="$COMP_CWORD"
      words=("${COMP_WORDS[@]}")
    fi

    local si="$IFS"
    IFS=$'\n' COMPREPLY=($(COMP_CWORD="$cword" \
                           COMP_LINE="$COMP_LINE" \
                           COMP_POINT="$COMP_POINT" \
                           npm completion -- "${words[@]}" \
                           2>/dev/null)) || return $?
    IFS="$si"
    if type __ltrim_colon_completions &>/dev/null; then
      __ltrim_colon_completions "${words[cword]}"
    fi
  }
  complete -o default -F _npm_completion npm
elif type compdef &>/dev/null; then
  _npm_completion() {
    local si=$IFS
      # if your npm command includes `install`
        if [[ ${words} =~ 'test' ]]; then
            _dirs
        else
            compadd -- $(COMP_CWORD=$((CURRENT-1)) \
                COMP_LINE=$BUFFER \
                COMP_POINT=0 \
                npm completion -- "${words[@]}" \
                2>/dev/null)
        fi
    IFS=$si
  }
  compdef _npm_completion npm
elif type compctl &>/dev/null; then
  _npm_completion () {
    local cword line point words si
    read -Ac words
    read -cn cword
    let cword-=1
    read -l line
    read -ln point
    si="$IFS"
    IFS=$'\n' reply=($(COMP_CWORD="$cword" \
                       COMP_LINE="$line" \
                       COMP_POINT="$point" \
                       npm completion -- "${words[@]}" \
                       2>/dev/null)) || return $?
    IFS="$si"
  }
  compctl -K _npm_completion npm
fi
###-end-npm-completion-###

bindkey "^[[H" beginning-of-line
bindkey "^[[F" end-of-line
bindkey "^[[3~" delete-char
bindkey "^[[1;3C" forward-word
bindkey "^[[1;3D" backward-word
